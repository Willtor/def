/** Repeatedly tries to set m_locked to 1,
 *  and takes the lock when m_locked is set to 1.
 */
def TAS_lock(m_locked * i32)-> void
begin
    while __builtin_swap(&(m_locked[0]), 1) == 1 do
    od
end

/** Sets lock to 0, representing that the thread
 *  has released the lock.
 */
def TAS_unlock(lock * i32) -> void
begin
    __builtin_swap (&(lock[0]), 0);
end

def TAS_try_acquire_lock (m_locked * i32)-> bool
begin
    return __builtin_swap(&(m_locked[0]), 1) != 1;
end

def TAS_not_taken(lock * i32) -> bool
begin
    return lock[0] == 0; 
end

var lock i32 = 0;
var THRESHOLD i32 = 4;
// should be u32 but def can't compare u32?
var _XBEGIN_STARTED i32 = -1I32;

export
def __defrts_hybrid_xbegin() -> void
begin
start:
    for var i i32 = 0; i < THRESHOLD; ++i do
        if __builtin_xbegin() == _XBEGIN_STARTED then
            while (!TAS_not_taken(&lock)) do
            od
            return;
        fi
    od
    if TAS_try_acquire_lock(&lock) then
        return;
    fi
    goto start;
end

export
def __defrts_hybrid_xend() -> void
begin
    if TAS_not_taken(&lock) then
        __builtin_xend;
    else
        TAS_unlock(&lock);
    fi
end
